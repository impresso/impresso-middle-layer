
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */


/**
 * Search find response (articles)
 */
export type SearchFindResponse = SearchFindResponse1 & SearchFindResponse2;
export type SearchFindResponse1 = BaseFindResponse;

export interface BaseFindResponse {
  /**
   * The number of items returned in this response
   */
  limit: number;
  /**
   * The number of items skipped in this response
   */
  skip: number;
  /**
   * The total number of items matching the query
   */
  total: number;
  /**
   * Additional information about the response.
   */
  info: {
    [k: string]: unknown;
  };
}
export interface SearchFindResponse2 {
  data: Article[];
}
/**
 * A journal/magazine article
 */
export interface Article {
  /**
   * The unique identifier of the article
   */
  uid: string;
  /**
   * The type of the article. NOTE: may be empty.
   */
  type: string;
  /**
   * The title of the article
   */
  title: string;
  /**
   * The size of the article in characters
   */
  size: number;
  /**
   * The number of pages in this article
   */
  nbPages: number;
  pages: Page[];
  /**
   * TODO
   */
  isCC: boolean;
  /**
   * The excerpt of the article
   */
  excerpt: string;
  locations?: Entity[];
  persons?: Entity[];
}
/**
 * A page of an article
 */
export interface Page {
  /**
   * The unique identifier of the page
   */
  uid: string;
  /**
   * The number of the page
   */
  num: number;
  /**
   * Reference to the article
   */
  issueUid: string;
  /**
   * Unique ID of the newspaper
   */
  newspaperUid: string;
  /**
   * The IIF image file name of the page
   */
  iiif: string;
  /**
   * The IIF image thumbnail file name of the page
   */
  iiifThumbnail: string;
  /**
   * The access rights code
   */
  accessRights: string;
  /**
   * Page labels
   */
  labels: string[];
  /**
   * Whether the page has coordinates
   */
  hasCoords: boolean;
  /**
   * Whether the page has errors
   */
  hasErrors: boolean;
  /**
   * Regions of the page
   */
  regions: {
    [k: string]: unknown;
  }[];
  /**
   * Whether the page image has been obfuscated because the user is not authorised to access it
   */
  obfuscated?: boolean;
  /**
   * The IIIF fragment of the page, image file name
   */
  iiifFragment?: string;
}
/**
 * An entity like location, person, etc
 */
export interface Entity {
  /**
   * Unique identifier of the entity
   */
  uid: string;
  /**
   * Relevance of the entity in the document
   */
  relevance: number;
}


/**
 * A journal/magazine article
 */
export interface Article {
  /**
   * The unique identifier of the article
   */
  uid: string;
  /**
   * The type of the article. NOTE: may be empty.
   */
  type: string;
  /**
   * The title of the article
   */
  title: string;
  /**
   * The size of the article in characters
   */
  size: number;
  /**
   * The number of pages in this article
   */
  nbPages: number;
  pages: Page[];
  /**
   * TODO
   */
  isCC: boolean;
  /**
   * The excerpt of the article
   */
  excerpt: string;
  locations?: Entity[];
  persons?: Entity[];
}
/**
 * A page of an article
 */
export interface Page {
  /**
   * The unique identifier of the page
   */
  uid: string;
  /**
   * The number of the page
   */
  num: number;
  /**
   * Reference to the article
   */
  issueUid: string;
  /**
   * Unique ID of the newspaper
   */
  newspaperUid: string;
  /**
   * The IIF image file name of the page
   */
  iiif: string;
  /**
   * The IIF image thumbnail file name of the page
   */
  iiifThumbnail: string;
  /**
   * The access rights code
   */
  accessRights: string;
  /**
   * Page labels
   */
  labels: string[];
  /**
   * Whether the page has coordinates
   */
  hasCoords: boolean;
  /**
   * Whether the page has errors
   */
  hasErrors: boolean;
  /**
   * Regions of the page
   */
  regions: {
    [k: string]: unknown;
  }[];
  /**
   * Whether the page image has been obfuscated because the user is not authorised to access it
   */
  obfuscated?: boolean;
  /**
   * The IIIF fragment of the page, image file name
   */
  iiifFragment?: string;
}
/**
 * An entity like location, person, etc
 */
export interface Entity {
  /**
   * Unique identifier of the entity
   */
  uid: string;
  /**
   * Relevance of the entity in the document
   */
  relevance: number;
}


export interface AuthenticationResponse {
  accessToken: string;
  authentication: {
    strategy?: string;
    payload?: {
      [k: string]: unknown;
    };
    [k: string]: unknown;
  };
  user: User;
}
/**
 * User details
 */
export interface User {
  id: number;
  username: string;
  firstname: string;
  lastname: string;
  isStaff: boolean;
  isActive: boolean;
  isSuperuser: boolean;
  uid: string;
}


export interface BaseFindResponse {
  /**
   * The number of items returned in this response
   */
  limit: number;
  /**
   * The number of items skipped in this response
   */
  skip: number;
  /**
   * The total number of items matching the query
   */
  total: number;
  /**
   * Additional information about the response.
   */
  info: {
    [k: string]: unknown;
  };
}


/**
 * Collectable Item find response
 */
export type CollectableItemFindResponse = CollectableItemFindResponse1 & CollectableItemFindResponse2;
export type CollectableItemFindResponse1 = BaseFindResponse;
export type StatusOfTheCollection = string;
export type NumberOfItemsInTheCollection = number | string;
export type UniqueIdentifierForTheUser = string;
export type UniqueUsernameForTheUserForOtherHumans = string;

export interface BaseFindResponse {
  /**
   * The number of items returned in this response
   */
  limit: number;
  /**
   * The number of items skipped in this response
   */
  skip: number;
  /**
   * The total number of items matching the query
   */
  total: number;
  /**
   * Additional information about the response.
   */
  info: {
    [k: string]: unknown;
  };
}
export interface CollectableItemFindResponse2 {
  data: CollectableItemGroup[];
}
/**
 * Collectable item group object
 */
export interface CollectableItemGroup {
  /**
   * The id of the collectable item group
   */
  itemId?: string;
  /**
   * Content type of the collectable item group: (A)rticle, (E)ntities, (P)ages, (I)ssues
   */
  contentType?: "A" | "E" | "P" | "I";
  /**
   * Ids of the collections
   */
  collectionIds?: string[];
  /**
   * Search queries
   */
  searchQueries?: string[];
  /**
   * Collection objects
   */
  collections?: Collection[];
  /**
   * The latest date added to the collectable item group
   */
  latestDateAdded?: string;
  [k: string]: unknown;
}
/**
 * Description of the collection object (Collection class)
 */
export interface Collection {
  uid: string;
  name: string;
  description: string;
  status: StatusOfTheCollection;
  creationDate: string;
  lastModifiedDate: string;
  countItems: NumberOfItemsInTheCollection;
  creator: BaseUser;
  labels?: string[];
}
export interface BaseUser {
  uid: UniqueIdentifierForTheUser;
  username: UniqueUsernameForTheUserForOtherHumans;
  [k: string]: unknown;
}


export type StatusOfTheCollection = string;
export type NumberOfItemsInTheCollection = number | string;
export type UniqueIdentifierForTheUser = string;
export type UniqueUsernameForTheUserForOtherHumans = string;

/**
 * Description of the collection object (Collection class)
 */
export interface Collection {
  uid: string;
  name: string;
  description: string;
  status: StatusOfTheCollection;
  creationDate: string;
  lastModifiedDate: string;
  countItems: NumberOfItemsInTheCollection;
  creator: BaseUser;
  labels?: string[];
}
export interface BaseUser {
  uid: UniqueIdentifierForTheUser;
  username: UniqueUsernameForTheUserForOtherHumans;
  [k: string]: unknown;
}


/**
 * Collections find response
 */
export type CollectionsFindResponse = CollectionsFindResponse1 & CollectionsFindResponse2;
export type CollectionsFindResponse1 = BaseFindResponse;
export type StatusOfTheCollection = string;
export type NumberOfItemsInTheCollection = number | string;
export type UniqueIdentifierForTheUser = string;
export type UniqueUsernameForTheUserForOtherHumans = string;

export interface BaseFindResponse {
  /**
   * The number of items returned in this response
   */
  limit: number;
  /**
   * The number of items skipped in this response
   */
  skip: number;
  /**
   * The total number of items matching the query
   */
  total: number;
  /**
   * Additional information about the response.
   */
  info: {
    [k: string]: unknown;
  };
}
export interface CollectionsFindResponse2 {
  data: Collection[];
}
/**
 * Description of the collection object (Collection class)
 */
export interface Collection {
  uid: string;
  name: string;
  description: string;
  status: StatusOfTheCollection;
  creationDate: string;
  lastModifiedDate: string;
  countItems: NumberOfItemsInTheCollection;
  creator: BaseUser;
  labels?: string[];
}
export interface BaseUser {
  uid: UniqueIdentifierForTheUser;
  username: UniqueUsernameForTheUserForOtherHumans;
  [k: string]: unknown;
}


export type StatusOfTheCollection = string;
export type NumberOfItemsInTheCollection = number | string;
export type UniqueIdentifierForTheUser = string;
export type UniqueUsernameForTheUserForOtherHumans = string;

/**
 * Description of the collection object (Collection class)
 */
export interface Collection {
  uid: string;
  name: string;
  description: string;
  status: StatusOfTheCollection;
  creationDate: string;
  lastModifiedDate: string;
  countItems: NumberOfItemsInTheCollection;
  creator: BaseUser;
  labels?: string[];
}
export interface BaseUser {
  uid: UniqueIdentifierForTheUser;
  username: UniqueUsernameForTheUserForOtherHumans;
  [k: string]: unknown;
}


/**
 * Remove collection response
 */
export interface RemoveCollectionResponse {
  params: {
    /**
     * The collection id
     */
    id?: string;
    /**
     * The status of the operation
     */
    status?: "DEL";
  };
  /**
   * Deletion task details
   */
  task: {
    /**
     * The ID of the task
     */
    task_id?: string;
    /**
     * When task was created
     */
    creationDate?: string;
  };
}


/**
 * Response for the find newspapers endpoint.
 */
export type FindNewspapersResponse = FindNewspapersResponse1 & FindNewspapersResponse2;
export type FindNewspapersResponse1 = BaseFindResponse;

export interface BaseFindResponse {
  /**
   * The number of items returned in this response
   */
  limit: number;
  /**
   * The number of items skipped in this response
   */
  skip: number;
  /**
   * The total number of items matching the query
   */
  total: number;
  /**
   * Additional information about the response.
   */
  info: {
    [k: string]: unknown;
  };
}
export interface FindNewspapersResponse2 {
  data: Newspaper[];
}
/**
 * A newspaper
 */
export interface Newspaper {
  /**
   * The unique identifier of the newspaper
   */
  uid: string;
  /**
   * The acronym of the newspaper
   */
  acronym: string;
  /**
   * The labels of the newspaper
   */
  labels: string[];
  /**
   * Language codes of the languages used in the newspaper
   */
  languages: string[];
  /**
   * TODO
   */
  properties?: NewspaperProperty[];
  /**
   * TODO
   */
  included: boolean;
  /**
   * Title of the newspaper
   */
  name: string;
  /**
   * Last available year of the newspaper articles
   */
  endYear: string;
  /**
   * First available year of the newspaper articles
   */
  startYear: string;
  firstIssue: NewspaperIssue;
  lastIssue: NewspaperIssue1;
  /**
   * The number of articles in the newspaper
   */
  countArticles: number;
  /**
   * The number of issues in the newspaper
   */
  countIssues: number;
  /**
   * The number of pages in the newspaper
   */
  countPages: number;
  /**
   * TODO
   */
  fetched?: boolean;
  /**
   * The number of years of the newspaper available
   */
  deltaYear: number;
}
export interface NewspaperProperty {
  /**
   * The name of the property
   */
  name: string;
  /**
   * The value of the property
   */
  value: string;
  /**
   * The label of the property
   */
  label: string;
  /**
   * Whether the value is a URL
   */
  isUrl?: boolean;
  [k: string]: unknown;
}
/**
 * First available issue of the newspaper
 */
export interface NewspaperIssue {
  /**
   * The unique identifier of the issue
   */
  uid: string;
  /**
   * TODO
   */
  cover: string;
  /**
   * The labels of the issue
   */
  labels: string[];
  /**
   * TODO
   */
  fresh: boolean;
  /**
   * TODO: list available options
   */
  accessRights: string;
  /**
   * The date of the issue
   */
  date: string;
  /**
   * The year of the issue
   */
  year: string;
}
/**
 * Last available issue of the newspaper
 */
export interface NewspaperIssue1 {
  /**
   * The unique identifier of the issue
   */
  uid: string;
  /**
   * TODO
   */
  cover: string;
  /**
   * The labels of the issue
   */
  labels: string[];
  /**
   * TODO
   */
  fresh: boolean;
  /**
   * TODO: list available options
   */
  accessRights: string;
  /**
   * The date of the issue
   */
  date: string;
  /**
   * The year of the issue
   */
  year: string;
}


/**
 * A newspaper
 */
export interface Newspaper {
  /**
   * The unique identifier of the newspaper
   */
  uid: string;
  /**
   * The acronym of the newspaper
   */
  acronym: string;
  /**
   * The labels of the newspaper
   */
  labels: string[];
  /**
   * Language codes of the languages used in the newspaper
   */
  languages: string[];
  /**
   * TODO
   */
  properties?: NewspaperProperty[];
  /**
   * TODO
   */
  included: boolean;
  /**
   * Title of the newspaper
   */
  name: string;
  /**
   * Last available year of the newspaper articles
   */
  endYear: string;
  /**
   * First available year of the newspaper articles
   */
  startYear: string;
  firstIssue: NewspaperIssue;
  lastIssue: NewspaperIssue1;
  /**
   * The number of articles in the newspaper
   */
  countArticles: number;
  /**
   * The number of issues in the newspaper
   */
  countIssues: number;
  /**
   * The number of pages in the newspaper
   */
  countPages: number;
  /**
   * TODO
   */
  fetched?: boolean;
  /**
   * The number of years of the newspaper available
   */
  deltaYear: number;
}
export interface NewspaperProperty {
  /**
   * The name of the property
   */
  name: string;
  /**
   * The value of the property
   */
  value: string;
  /**
   * The label of the property
   */
  label: string;
  /**
   * Whether the value is a URL
   */
  isUrl?: boolean;
  [k: string]: unknown;
}
/**
 * First available issue of the newspaper
 */
export interface NewspaperIssue {
  /**
   * The unique identifier of the issue
   */
  uid: string;
  /**
   * TODO
   */
  cover: string;
  /**
   * The labels of the issue
   */
  labels: string[];
  /**
   * TODO
   */
  fresh: boolean;
  /**
   * TODO: list available options
   */
  accessRights: string;
  /**
   * The date of the issue
   */
  date: string;
  /**
   * The year of the issue
   */
  year: string;
}
/**
 * Last available issue of the newspaper
 */
export interface NewspaperIssue1 {
  /**
   * The unique identifier of the issue
   */
  uid: string;
  /**
   * TODO
   */
  cover: string;
  /**
   * The labels of the issue
   */
  labels: string[];
  /**
   * TODO
   */
  fresh: boolean;
  /**
   * TODO: list available options
   */
  accessRights: string;
  /**
   * The date of the issue
   */
  date: string;
  /**
   * The year of the issue
   */
  year: string;
}


/**
 * TODO: review this schema
 */
export interface Pagination {
  /**
   * Limit to this many items
   */
  limit?: number;
  /**
   * Skip this many items
   */
  offset?: number;
  /**
   * Skip this many items
   */
  skip?: number;
  /**
   * Display N-th page (using 'limit' as the number of items in the page)
   */
  page?: number;
  /**
   * Total items available
   */
  total?: number;
  [k: string]: unknown;
}


/**
 * Search find response (articles)
 */
export type SearchFindResponse = SearchFindResponse1 & SearchFindResponse2;
export type SearchFindResponse1 = BaseFindResponse;

export interface BaseFindResponse {
  /**
   * The number of items returned in this response
   */
  limit: number;
  /**
   * The number of items skipped in this response
   */
  skip: number;
  /**
   * The total number of items matching the query
   */
  total: number;
  /**
   * Additional information about the response.
   */
  info: {
    [k: string]: unknown;
  };
}
export interface SearchFindResponse2 {
  data: Article[];
}
/**
 * A journal/magazine article
 */
export interface Article {
  /**
   * The unique identifier of the article
   */
  uid: string;
  /**
   * The type of the article. NOTE: may be empty.
   */
  type: string;
  /**
   * The title of the article
   */
  title: string;
  /**
   * The size of the article in characters
   */
  size: number;
  /**
   * The number of pages in this article
   */
  nbPages: number;
  pages: Page[];
  /**
   * TODO
   */
  isCC: boolean;
  /**
   * The excerpt of the article
   */
  excerpt: string;
  locations?: Entity[];
  persons?: Entity[];
}
/**
 * A page of an article
 */
export interface Page {
  /**
   * The unique identifier of the page
   */
  uid: string;
  /**
   * The number of the page
   */
  num: number;
  /**
   * Reference to the article
   */
  issueUid: string;
  /**
   * Unique ID of the newspaper
   */
  newspaperUid: string;
  /**
   * The IIF image file name of the page
   */
  iiif: string;
  /**
   * The IIF image thumbnail file name of the page
   */
  iiifThumbnail: string;
  /**
   * The access rights code
   */
  accessRights: string;
  /**
   * Page labels
   */
  labels: string[];
  /**
   * Whether the page has coordinates
   */
  hasCoords: boolean;
  /**
   * Whether the page has errors
   */
  hasErrors: boolean;
  /**
   * Regions of the page
   */
  regions: {
    [k: string]: unknown;
  }[];
  /**
   * Whether the page image has been obfuscated because the user is not authorised to access it
   */
  obfuscated?: boolean;
  /**
   * The IIIF fragment of the page, image file name
   */
  iiifFragment?: string;
}
/**
 * An entity like location, person, etc
 */
export interface Entity {
  /**
   * Unique identifier of the entity
   */
  uid: string;
  /**
   * Relevance of the entity in the document
   */
  relevance: number;
}


/**
 * ID of the text reuse passage
 */
export type PassageID = string;

export interface FindTextReuseClustersResponse {
  clusters: GetTextReuseClusterResponse[];
  info: Pagination;
}
export interface GetTextReuseClusterResponse {
  cluster: TextReuseCluster;
  textSample: string;
  details?: TextReuseClusterDetails;
}
/**
 * Represents a cluster of text reuse passages
 */
export interface TextReuseCluster {
  id: PassageID;
  /**
   * Percentage of overlap between passages in the cluster
   */
  lexicalOverlap?: number;
  /**
   * Number of passages in cluster
   */
  clusterSize?: number;
  /**
   * Number of connected clusters
   */
  connectedClustersCount?: number;
  /**
   * Time window covered by documents in the cluster
   */
  timeCoverage?: {
    from?: string;
    to?: string;
  };
}
/**
 * Extra details of the cluster
 */
export interface TextReuseClusterDetails {
  facets: Facet[];
  /**
   * Resolution for the 'date' facet
   */
  resolution?: "year" | "month" | "day";
}
export interface Facet {
  /**
   * Facet type
   */
  type?: string;
  /**
   * Number of buckets
   */
  numBuckets?: number;
  buckets?: {
    [k: string]: unknown;
  }[];
}
/**
 * TODO: review this schema
 */
export interface Pagination {
  /**
   * Limit to this many items
   */
  limit?: number;
  /**
   * Skip this many items
   */
  offset?: number;
  /**
   * Skip this many items
   */
  skip?: number;
  /**
   * Display N-th page (using 'limit' as the number of items in the page)
   */
  page?: number;
  /**
   * Total items available
   */
  total?: number;
  [k: string]: unknown;
}


/**
 * ID of the text reuse passage
 */
export type PassageID = string;

export interface GetTextReuseClusterResponse {
  cluster: TextReuseCluster;
  textSample: string;
  details?: TextReuseClusterDetails;
}
/**
 * Represents a cluster of text reuse passages
 */
export interface TextReuseCluster {
  id: PassageID;
  /**
   * Percentage of overlap between passages in the cluster
   */
  lexicalOverlap?: number;
  /**
   * Number of passages in cluster
   */
  clusterSize?: number;
  /**
   * Number of connected clusters
   */
  connectedClustersCount?: number;
  /**
   * Time window covered by documents in the cluster
   */
  timeCoverage?: {
    from?: string;
    to?: string;
  };
}
/**
 * Extra details of the cluster
 */
export interface TextReuseClusterDetails {
  facets: Facet[];
  /**
   * Resolution for the 'date' facet
   */
  resolution?: "year" | "month" | "day";
}
export interface Facet {
  /**
   * Facet type
   */
  type?: string;
  /**
   * Number of buckets
   */
  numBuckets?: number;
  buckets?: {
    [k: string]: unknown;
  }[];
}


/**
 * Collections find response
 */
export type TextReusePassageFindResponse = TextReusePassageFindResponse1 & TextReusePassageFindResponse2;
export type TextReusePassageFindResponse1 = BaseFindResponse;
/**
 * ID of the text reuse passage
 */
export type PassageID = string;
/**
 * ID of the article
 */
export type ArticleID = string;
/**
 * ID of the cluster
 */
export type ClusterID = string;
/**
 * The size of the cluster
 */
export type ClusterSize = number;
/**
 * The time difference in days between the two articles
 */
export type TimeDifferenceInDays = number;
/**
 * The lexical overlap between the two articles
 */
export type LexicalOverlap = number;

export interface BaseFindResponse {
  /**
   * The number of items returned in this response
   */
  limit: number;
  /**
   * The number of items skipped in this response
   */
  skip: number;
  /**
   * The total number of items matching the query
   */
  total: number;
  /**
   * Additional information about the response.
   */
  info: {
    [k: string]: unknown;
  };
}
export interface TextReusePassageFindResponse2 {
  data: TextReusePassage[];
}
/**
 * Represents a passage of text that was identified as a part of a text reuse cluster
 */
export interface TextReusePassage {
  id: PassageID;
  article: ArticleDetails;
  textReuseCluster: ClusterDetails;
  /**
   * Offset of the passage in the article text
   */
  offsetStart: number;
  /**
   * Offset of the passage in the article text
   */
  offsetEnd: number;
  /**
   * Textual content of the passage
   */
  content: string;
  /**
   * Title of the content item (article) where this passage was found
   */
  title: string;
  /**
   * Details of the connected clusters
   */
  connectedClusters?: {
    /**
     * ID of the connected cluster
     */
    id: string;
  };
  /**
   * TBD
   */
  isFront?: boolean;
  /**
   * Size of the passage
   */
  size?: number;
  /**
   * Newspaper details
   */
  newspaper?: {
    /**
     * ID of the newspaper
     */
    id: string;
  };
  /**
   * Issue details
   */
  issue?: {
    /**
     * ID of the issue
     */
    id: string;
  };
  /**
   * Date of the item (article) where this passage was found
   */
  date?: string;
  /**
   * Bounding box of the passage in the page
   */
  pageRegions: string[];
  /**
   * Numbers of the pages where the passage was found
   */
  pageNumbers: number[];
  /**
   * Collection IDs the passage belongs to
   */
  collections: string[];
}
/**
 * Details of the article the passage belongs to
 */
export interface ArticleDetails {
  id: ArticleID;
}
/**
 * Details of the cluster the passage belongs to
 */
export interface ClusterDetails {
  id: ClusterID;
  clusterSize: ClusterSize;
  timeDifferenceDay?: TimeDifferenceInDays;
  lexicalOverlap?: LexicalOverlap;
}


/**
 * ID of the text reuse passage
 */
export type PassageID = string;
/**
 * ID of the article
 */
export type ArticleID = string;
/**
 * ID of the cluster
 */
export type ClusterID = string;
/**
 * The size of the cluster
 */
export type ClusterSize = number;
/**
 * The time difference in days between the two articles
 */
export type TimeDifferenceInDays = number;
/**
 * The lexical overlap between the two articles
 */
export type LexicalOverlap = number;
/**
 * Offset of the passage in the article text
 */
export type Offset = number;

/**
 * Represents a passage of text that was identified as a part of a text reuse cluster
 */
export interface TextReusePassage {
  id: PassageID;
  article: ArticleDetails;
  textReuseCluster: ClusterDetails;
  offsetStart: Offset;
  offsetEnd: Offset;
  /**
   * Textual content of the passage
   */
  content: string;
  /**
   * Title of the content item (article) where this passage was found
   */
  title: string;
  /**
   * Details of the connected clusters
   */
  connectedClusters?: {
    /**
     * ID of the connected cluster
     */
    id: string;
  };
  /**
   * TBD
   */
  isFront?: boolean;
  /**
   * Size of the passage
   */
  size?: number;
  /**
   * Newspaper details
   */
  newspaper?: {
    /**
     * ID of the newspaper
     */
    id: string;
  };
  /**
   * Issue details
   */
  issue?: {
    /**
     * ID of the issue
     */
    id: string;
  };
  /**
   * Date of the item (article) where this passage was found
   */
  date?: string;
  /**
   * Bounding box of the passage in the page
   */
  pageRegions: string[];
  /**
   * Numbers of the pages where the passage was found
   */
  pageNumbers: number[];
  /**
   * Collection IDs the passage belongs to
   */
  collections: string[];
}
/**
 * Details of the article the passage belongs to
 */
export interface ArticleDetails {
  id: ArticleID;
}
/**
 * Details of the cluster the passage belongs to
 */
export interface ClusterDetails {
  id: ClusterID;
  clusterSize: ClusterSize;
  timeDifferenceDay?: TimeDifferenceInDays;
  lexicalOverlap?: LexicalOverlap;
}


/**
 * Version of the API. Contains information about the current version of the API, features, etc.
 */
export interface APIVersion {
  solr: {
    endpoints?: {
      /**
       * This interface was referenced by `undefined`'s JSON-Schema definition
       * via the `patternProperty` "^.*".
       */
      [k: string]: string;
    };
    [k: string]: unknown;
  };
  mysql: {
    endpoint?: string;
    [k: string]: unknown;
  };
  version: string;
  apiVersion: {
    branch?: string;
    revision?: string;
    version?: string;
    [k: string]: unknown;
  };
  documentsDateSpan: {
    start?: {
      [k: string]: unknown;
    };
    end?: {
      [k: string]: unknown;
    };
    [k: string]: unknown;
  };
  newspapers: {
    /**
     * This interface was referenced by `undefined`'s JSON-Schema definition
     * via the `patternProperty` "^.*".
     */
    [k: string]: {
      name?: string;
      [k: string]: unknown;
    };
  };
  features: {
    /**
     * This interface was referenced by `undefined`'s JSON-Schema definition
     * via the `patternProperty` "^.*".
     */
    [k: string]: {
      [k: string]: unknown;
    };
  };
}
